<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Senior Connect - Daily Emoji Check-In</title>
  <link rel="stylesheet" href="/styles.css" />
</head>

<body>
  <div id="headerText"></div> <!-- Top text, changes based on the time of day-->

  <div id="gameArea"> <!--The div that stores the items and the baskets -->

    <div id="tray" role="list"></div> <!-- the tray, can be reordered by swapping with the baskets -->
    <div class="baskets" id="baskets"></div> <!-- the baskets, can be reordered by swapping with the tray -->
    <div id="message" aria-live="polite"></div> <!-- message that appears after check-in completion -->

  </div>

    <!-- Dropdown for changing the language -->
    <label for="languageSelect">Translate to: </label>
    <select id="languageSelect" onchange="handleLanguageChange(this.value)"> <!-- get the value (lang code) of chosen language--> 
        <option value="en" selected>English</option>
        
        <option value="zh">Chinese (Mandarin)</option>
        <option value="ms">Malay</option>
        <option value="ta">Tamil</option>

  <script>
    // Map Database for holding content to translate
    const transText = {
      // English is the default language 
      'en': {
        // Headertext
        'MORNING': "Good Morning! Drag the emojis to their matching spots",
        'AFTERNOON': "Good Afternoon! Drag the emojis to their matching spots",
        'EVENING': "Good Evening! Drag the emojis to their matching spots",
        'NIGHT': "Good Night! Drag the emojis to their matching spots",

        // Extra (message)
        'text1': "Checking in...",
        'text2': "Check-in recorded successfully! ğŸ’›",
        'text3': "Couldn't connect. Try again later ğŸ™",
        'text4': "Not quite right, try again ğŸ™",
        'text51': "Selected",
        'text52': ". Drag to a basket to place",
        'text6': "Drag an item from the tray to their matching basket.",
      },
      // Other language start empty. (Will be filled after translating API)
      'zh': null,
      'ms': null,
      'ta': null,
    };

    // Active language code
    let activeLangCode = 'en';

    // Store the transText map into a variable as a copy 
    let currentContent = transText[activeLangCode]; 

    // Function for changing the language
    async function handleLanguageChange(targetLangCode) {
      activeLangCode = targetLangCode;
      
      // Check cache
      if (transText[targetLangCode]) {
        // Content already translated and stored (Cache Hit)
        currentContent = transText[targetLangCode];
        
        // Call the function again to change the title to translated version and return the variable
        setTimeBasedBackground(currentContent);
        return currentContent;
      }

      // Translate (Cache Miss)
      // Always translate FROM english source
      const englishTexts = Object.values(transText.en);
      const originalKeys = Object.keys(transText.en);

      try {
        const response = await fetch('/api/translate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ texts: englishTexts, targetLang: targetLangCode })
        });
    
        // Check if the HTTP status is successful (200-299)
        if (!response.ok) {
            // Read the body as text to get the server's error message
            const errorText = await response.text(); 
            
            // Throw a custom error that includes the server's status and message
            throw new Error(`Server translation failed (Status: ${response.status}). Detail: ${errorText.substring(0, 150)}...`);
        }

        // Safely parse the JSON data ONLY if the response was successful
        const data = await response.json();

        // ... (check response, get data)
        const translatedStrings = data.translations;

        // Build and store
        const newContent = {};
        originalKeys.forEach((key, index) => {
          newContent[key] = translatedStrings[index];
        });

        // Store the translated map in the database
        transText[targetLangCode] = newContent;

        // Update the currentContent variable
        currentContent = transText[targetLangCode];

        // This calls the title again for the translated version (also works as a check)
        setTimeBasedBackground(currentContent);

      } catch (error){
        // Catch block to handle network errors and customer error thrown
        console.error('Translation error:', error);

        // Revert dropdown state on failure
        document.getElementById('languageSelect').value = 'en';
        activeLangCode = 'en';

        // Base language console log for error
        console.error('Translation failed. Please check console for details: ' + error.message);
      }
    }

    // all the available emojis, the general theme is nice things, animals and food
    const allEmojis = ["â˜€ï¸", "ğŸŒ¸", "ğŸ", "ğŸŒˆ", "ğŸ¢", "ğŸ•Šï¸", "ğŸŒ»", "ğŸ±", "ğŸ‹", "ğŸ‰", "ğŸ•", "ğŸŒ¹", "ğŸŒ™", "ğŸ‡", "ğŸŒ¾", "ğŸ‡", "ğŸŒ¼", "ğŸŠ", "ğŸ ", "ğŸ¦‹", "ğŸ€", "ğŸŒº", "ğŸ¦", "ğŸ¦œ", "ğŸŒ´", "ğŸ’", "ğŸŒ·", "ğŸ„", "ğŸª´"];

    // use math to come up with a seed - current year * 10000 + (current month + 1) * 100 + current date
    // ex: 29-10-2025 = 2025 * 10000 + (10 + 1) * 100 + 29
    // 20251129
    function getDailySeed() {
      const t = new Date();
      return t.getFullYear() * 10000 + (t.getMonth() + 1) * 100 + t.getDate();
      console.log(t.getDate())
    }
    // uses Math library, makes a random-looking number based on a given seed, which will be a number between 0 and 1
    // if you don't have this the emojis and everything don't load
    function seededRandom(seed) {
      const x = Math.sin(seed) * 10000;
      return x - Math.floor(x);
    }

    // get emoji function, runs 3 times for 3 emojis
    function getDailyEmojis(count = 3) {
      // copy emoji list
      const copy = [...allEmojis];
      // make a empty list to store emojis
      const chosen = [];
      // call generate seed command
      const seed = getDailySeed();
      // let i = 0, count up to 3, and for each number, get emoji
      for (let i = 0; i < count; i++) {
        const idx = Math.floor(seededRandom(seed + i) * copy.length);
        chosen.push(copy[idx]);
        copy.splice(idx, 1);
      }
      // return the list of emojis
      return chosen;
    }
    // Shuffle the list (random, more engaging)
    function shuffleArray(a) {
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    // Change background and text colour based on time of day
    function setTimeBasedBackground(content) {
      // get hour (ex: 23)
      const hour = new Date().getHours();
      let bg, greeting, textcol = '#333', isNight = false;
      if (hour >= 6 && hour < 12) { bg = 'linear-gradient(to top,#fdebd0,#f6ddcc,#fad7a0)'; greeting = content.MORNING; }
      else if (hour >= 12 && hour < 18) { bg = 'linear-gradient(to top,#ffd89b,#ffb347)'; greeting = content.AFTERNOON; }
      else if (hour >= 18 && hour < 20) { bg = 'linear-gradient(to top,#f6a98f,#f28e63)'; greeting = content.EVENING; }
      else { bg = 'linear-gradient(to top,#2c3e50,#34495e)'; greeting = content.NIGHT; textcol = 'white'; isNight = true; }
      document.body.style.background = bg;
      document.getElementById('headerText').textContent = greeting;
      document.getElementById('headerText').style.color = textcol;
      // Change basket colours when it's night
      document.querySelectorAll('.basket').forEach(b => {
        if (isNight) {
          b.style.background = 'linear-gradient(to top,#4b5c6b,#2c3e50)';
          b.style.borderColor = '#fff';
          b.style.color = '#fff';
        } else {
          b.style.background = 'linear-gradient(to top,#fffbe6,#ffe0b2)';
          b.style.borderColor = '#f6c67a';
          b.style.color = '#333';
        }
      });
    }

    // select elements on screen (baskets, tray, message)
    const basketsEl = document.getElementById('baskets');
    const trayEl = document.getElementById('tray');
    const messageEl = document.getElementById('message');

    // call the dailyemoji function, send these to the tray, shuffle them
    const dailyEmojis = getDailyEmojis(3);
    const trayEmojis = shuffleArray([...dailyEmojis]);

    // for each emoji, make a div for a basket
    dailyEmojis.forEach(e => {
      const b = document.createElement('div');
      b.className = 'basket';
      b.dataset.item = e;
      b.innerHTML = `<span class="hint">${e}</span>`;
      basketsEl.appendChild(b);
    });

    // makes 1 div per emoji in the tray
    trayEmojis.forEach(e => {
      const it = document.createElement('div'); // make box
      it.className = 'item'; // assign classname 'item'
      it.textContent = e; // write the emoji into it as text
      it.dataset.item = e; // stores the emoji's value in data-item
      trayEl.appendChild(it); // add to the tray area
    });

    setTimeBasedBackground(currentContent);

    // define matched variable, and set the number of needed tiles matched to check in at 2
    let matched = 0;
    const totalNeeded = 2;
    let activeClone = null;
    let activeSource = null;
    let selectedForTap = null;

    function basketAtPoint(x, y) {
      const el = document.elementFromPoint(x, y);
      if (!el) return null;
      return el.closest('.basket');
    }

    function createClone(text, x, y) {
      const c = document.createElement('div');
      c.className = 'item dragging';
      c.style.position = 'fixed';
      c.style.left = (x - 36) + 'px';
      c.style.top = (y - 36) + 'px';
      c.style.zIndex = 9999;
      c.style.pointerEvents = 'none';
      c.textContent = text;
      document.body.appendChild(c);
      return c;
    }

    function destroyClone() {
      if (activeClone) { activeClone.remove(); activeClone = null; }
      if (activeSource) activeSource.classList.remove('dragging');
      activeSource = null;
    }

    function placeInBasket(basket, emoji, content) {
      basket.classList.add('filled');
      basket.innerHTML = `<span>${emoji}</span>`;
      const src = trayEl.querySelector(`.item[data-item='${emoji}']`);
      if (src) src.remove();
      matched++;
      messageEl.textContent = matched === totalNeeded ? content.text1 : ''; //
      if (matched === totalNeeded) {
        setTimeout(() => {
          fetch("/checkin", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ name: "Elderly User", status: "checked in" })
          })
            .then(r => r.json())
            .then(result => { messageEl.textContent = content.text2; console.log(result); })
            .catch(err => { messageEl.textContent = content.text3; console.error(err); });
        }, 400);
      }
    }

    // Mouse drag for desktop
    let mouseMoveHandler = null, mouseUpHandler = null;
    function onItemMouseDown(e) {
      e.preventDefault();
      const item = e.currentTarget;
      const emoji = item.dataset.item;
      activeSource = item;
      activeSource.classList.add('dragging');
      activeClone = createClone(emoji, e.clientX, e.clientY);
      mouseMoveHandler = function (ev) { activeClone.style.left = (ev.clientX - 36) + 'px'; activeClone.style.top = (ev.clientY - 36) + 'px'; };
      mouseUpHandler = function (ev) {
        const basket = basketAtPoint(ev.clientX, ev.clientY);
        if (basket && basket.dataset.item === emoji && !basket.classList.contains('filled')) placeInBasket(basket, emoji, currentContent); //
        else messageEl.textContent = currentContent.text4; //
        destroyClone();
        document.removeEventListener('mousemove', mouseMoveHandler);
        document.removeEventListener('mouseup', mouseUpHandler);
      };
      document.addEventListener('mousemove', mouseMoveHandler);
      document.addEventListener('mouseup', mouseUpHandler);
    }

    // Touch drag for mobile
    let touchMoveHandler = null, touchEndHandler = null;
    function onItemTouchStart(e) {
      if (e.touches.length > 1) return;
      e.preventDefault();
      const item = e.currentTarget;
      const emoji = item.dataset.item;
      activeSource = item;
      activeSource.classList.add('dragging');
      const t = e.touches[0];
      activeClone = createClone(emoji, t.clientX, t.clientY);
      touchMoveHandler = function (ev) {
        if (ev.touches.length === 0) return;
        const tt = ev.touches[0];
        activeClone.style.left = (tt.clientX - 36) + 'px';
        activeClone.style.top = (tt.clientY - 36) + 'px';
      };
      touchEndHandler = function (ev) {
        const changed = ev.changedTouches && ev.changedTouches[0];
        const cx = changed ? changed.clientX : window.innerWidth / 2;
        const cy = changed ? changed.clientY : window.innerHeight / 2;
        const basket = basketAtPoint(cx, cy);
        if (basket && basket.dataset.item === emoji && !basket.classList.contains('filled')) placeInBasket(basket, emoji, currentContent);
        else messageEl.textContent = currentContent.text4;
        destroyClone();
        document.removeEventListener('touchmove', touchMoveHandler, { passive: false });
        document.removeEventListener('touchend', touchEndHandler);
      };
      document.addEventListener('touchmove', touchMoveHandler, { passive: false });
      document.addEventListener('touchend', touchEndHandler);
    }

    // Tap-to-select fallback
    function onItemTap(e) {
      const it = e.currentTarget;
      if (selectedForTap === it) { it.classList.remove('selected'); selectedForTap = null; messageEl.textContent = ''; return; }
      if (selectedForTap) selectedForTap.classList.remove('selected');
      selectedForTap = it;
      it.classList.add('selected');
      messageEl.textContent = currentContent.text51 + it.dataset.item + currentContent.text52; // have to split into 2 strings
    }
    function onBasketTap(e) {
      const b = e.currentTarget;
      if (!selectedForTap) { messageEl.textContent = currentContent.text6; return; } //
      const emoji = selectedForTap.dataset.item;
      if (b.dataset.item === emoji && !b.classList.contains('filled')) placeInBasket(b, emoji, currentContent); //
      else { messageEl.textContent = currentContent.text4; selectedForTap.classList.remove('selected'); selectedForTap = null; } //
    }

    // Attach handlers
    document.querySelectorAll('.item').forEach(it => {
      it.addEventListener('mousedown', onItemMouseDown);
      it.addEventListener('touchstart', onItemTouchStart, { passive: false });
      it.addEventListener('click', onItemTap);
    });
    document.querySelectorAll('.basket').forEach(b => {
      b.addEventListener('mouseenter', () => b.classList.add('active'));
      b.addEventListener('mouseleave', () => b.classList.remove('active'));
      b.addEventListener('click', onBasketTap);
    });

  </script>
</body>

</html>