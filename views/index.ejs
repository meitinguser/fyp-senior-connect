<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Senior Connect - Daily Picture Check-In</title>
  <link rel="stylesheet" href="/styles.css" />
</head>

<body>
  <div id="headerText"></div> <!-- Top text, changes based on the time of day-->

  <div id="gameArea"> <!--The div that stores the items and the baskets -->

    <div id="tray" role="list"></div> <!-- the tray, can be reordered by swapping with the baskets -->
    <div class="baskets" id="baskets"></div> <!-- the baskets, can be reordered by swapping with the tray -->
    <div id="message" aria-live="polite"></div> <!-- message that appears after check-in completion -->

  </div>

  <!-- Dropdown for changing the language -->
  <div class="language-selector-container">
    <label for="languageSelect">Select Language:</label>
    <select id="languageSelect" onchange="handleLanguageChange(this.value)">
      <!-- get the value (lang code) of chosen language-->
      <option value="en" selected>English</option>
      <option value="zh">Chinese (Mandarin)</option>
      <option value="ms">Malay</option>
      <option value="ta">Tamil</option>
    </select>
  </div>



  <script>
    // Map Database for holding content to translate
    const transText = {
      // English is the default language 

      'en': {
        // Headertext
        'MORNING': "Good Morning! Drag the picture to its place",
        'AFTERNOON': "Good Afternoon! Drag the picture to its place",
        'EVENING': "Good Evening! Drag the picture to its place",
        'NIGHT': "Good Night! Drag the picture to its place",

        // Extra (message)
        'text1': "Checking in...",
        'text2': "Check-in recorded successfully! ðŸ’›",
        'text3': "Couldn't connect. Try again later ðŸ™",
        'text4': "Not quite right, try again ðŸ™",
        'text51': "Selected ",
        'text52': ". Drag to a basket to place",
        'text6': "Drag an item from the tray to their matching basket.",
      },
      // Other language start empty. (Will be filled after translating API)
      'zh': null,
      'ms': null,
      'ta': null,
    };

    // Active language code
    let activeLangCode = 'en';

    // Store the transText map into a variable as a copy 
    let currentContent = transText[activeLangCode];

    // Function for changing the language
    async function handleLanguageChange(targetLangCode) {
      activeLangCode = targetLangCode;

      // Check cache
      if (transText[targetLangCode]) {
        // Content already translated and stored (Cache Hit)
        currentContent = transText[targetLangCode];

        // Call the function again to change the title to translated version and return the variable
        setTimeBasedBackground(currentContent);
        return currentContent;
      }

      // Translate (Cache Miss)
      // Always translate FROM english source
      const englishTexts = Object.values(transText.en);
      const originalKeys = Object.keys(transText.en);

      try {
        const response = await fetch('/api/translate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ texts: englishTexts, targetLang: targetLangCode })
        });

        // Check if the HTTP status is successful (200-299)
        if (!response.ok) {
          // Read the body as text to get the server's error message
          const errorText = await response.text();

          // Throw a custom error that includes the server's status and message
          throw new Error(`Server translation failed (Status: ${response.status}). Detail: ${errorText.substring(0, 150)}...`);
        }

        // Safely parse the JSON data ONLY if the response was successful
        const data = await response.json();

        // ... (check response, get data)
        const translatedStrings = data.translations;

        // Build and store
        const newContent = {};
        originalKeys.forEach((key, index) => {
          newContent[key] = translatedStrings[index];
        });

        // Store the translated map in the database
        transText[targetLangCode] = newContent;

        // Update the currentContent variable
        currentContent = transText[targetLangCode];

        // This calls the title again for the translated version (also works as a check)
        setTimeBasedBackground(currentContent);

      } catch (error) {
        // Catch block to handle network errors and customer error thrown
        console.error('Translation error:', error);

        // Revert dropdown state on failure
        document.getElementById('languageSelect').value = 'en';
        activeLangCode = 'en';

        // Base language console log for error
        console.error('Translation failed. Please check console for details: ' + error.message);
      }
    }


    /* ================== CONFIG ================== */
    // ðŸŽ® Choose a random game mode each time the page loads
    const allGames = ["flowers", "sorting"];
    const gameMode = allGames[Math.floor(Math.random() * allGames.length)];
    console.log("Active game:", gameMode);

    /* ================== GAME LOGIC ================== */
    const allItems = ["whitelily", "pinkflower", "blueflower", "rose", "maroonchrysanthemum"];
    function imagePath(name) { return `/images/${name}.png`; }
    const basketImagePath = "/images/cartoon-basket.png";


  // All datasets 
    const datasets = {
    berries: ["strawberry", "blueberry", "cherry-tomato"],
    flowers: ["whitelily", "pinkflower", "blueflower", "rose", "maroonchrysanthemum"],
    fruits: ["apple", "banana", "orange"],
    veggies: ["carrot", "broccoli", "potato"],
    animals: ["cat", "dog", "bird"]
  };

    // Pick ONE dataset
    const flowerDatasetKeys = Object.keys(datasets);
    const chosenDatasetKey = flowerDatasetKeys[Math.floor(Math.random() * flowerDatasetKeys.length)];
    const chosenDataset = datasets[chosenDatasetKey]; 

    console.log("Dataset selected for flower game:", chosenDatasetKey, chosenDataset);

    const flowerItems = chosenDataset;



    // use math to come up with a seed - current year * 10000 + (current month + 1) * 100 + current date
    // ex: 29-10-2025 = 2025 * 10000 + (10 + 1) * 100 + 29
    // 20251129 
    function getDailySeed() {
      const t = new Date();
      return t.getFullYear() * 10000 + (t.getMonth() + 1) * 100 + t.getDate();
    }
    // uses Math library, makes a random-looking number based on a given seed, which will be a number between 0 and 1
    // if you don't have this, everything doesn't load
    function seededRandom(seed) {
      const x = Math.sin(seed) * 10000;
      return x - Math.floor(x);
    }
    function getDailyEmojis(count = 3) {
      const copy = [...allItems];
      const chosen = [];
      const seed = getDailySeed() + Math.floor(Math.random() * 1000); // Add randomness
      for (let i = 0; i < count; i++) {
        const idx = Math.floor(seededRandom(seed + i) * copy.length);
        chosen.push(copy[idx]);
        copy.splice(idx, 1);
      }
      return chosen;
    }

    
    function shuffleArray(a) {
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function setTimeBasedBackground(content) {
      const hour = new Date().getHours();
      let bg, greeting, textcol = '#333';
      if (hour >= 6 && hour < 12) { bg = 'linear-gradient(to top,#fdebd0,#f6ddcc,#fad7a0)'; greeting = content.MORNING; }
      else if (hour >= 12 && hour < 18) { bg = 'linear-gradient(to top,#ffd89b,#ffb347)'; greeting = content.AFTERNOON; }
      else if (hour >= 18 && hour < 20) { bg = 'linear-gradient(to top,#f6a98f,#f28e63)'; greeting = content.EVENING; }
      else { bg = 'linear-gradient(to top,#2c3e50,#34495e)'; greeting = content.NIGHT; textcol = 'white'; }
      document.body.style.background = bg;
      document.getElementById('headerText').textContent = greeting;
      document.getElementById('headerText').style.color = textcol;
      document.getElementById('message').style.color = textcol;

    }

    const basketsEl = document.getElementById('baskets');
    const trayEl = document.getElementById('tray');
    const messageEl = document.getElementById('message');

    const dailyEmojis = shuffleArray([...chosenDataset]).slice(0, 3);
    const trayEmojis = shuffleArray([...dailyEmojis]);

    // ======== inside build baskets section ======== 
    if (gameMode === "sorting") {
      dailyEmojis.forEach(e => {
        const b = document.createElement('div');
        b.className = 'basket';
        b.dataset.item = e;
        // No basket image now â€” only faded target image
        b.innerHTML = `
          <img src="${imagePath(e)}" 
              alt="Target ${e}" 
              class="hint" 
              draggable="false" 
              style="opacity:0.3;transition:opacity 0.3s ease;width:100%;height:auto;">
        `;
        basketsEl.appendChild(b);
      });
    } if (gameMode === "flowers") {
      const b = document.createElement('div');
      b.className = 'basket';
      b.dataset.item = 'flowers';

      // Main basket image
      b.innerHTML = 
      `<img src="${basketImagePath}" alt="Basket for flowers" draggable="false" style="width:300px; opacity=1.0">`;

      // Add only the daily selected flowers as faded
      dailyEmojis.forEach(flower => {
        const img = document.createElement('img');
        img.src = imagePath(flower);
        img.alt = flower;
        img.className = 'placed-item';
        img.style.opacity = 0.4; // faded initially
        img.style.position = 'absolute';
        img.style.left = `${10 + Math.random() * 15}%`;
        img.style.right = `${10 + Math.random() * 15}%`;
        img.style.width = "80%";
        img.style.height = "80%";

        img.style.transition = 'opacity 0.3s ease';
        b.appendChild(img);
      });

      basketsEl.appendChild(b);
    }


    // --- Build tray ---
    trayEmojis.forEach(e => {
      const it = document.createElement('div');
      it.className = 'item';
      it.dataset.item = e;
      it.innerHTML = `<img src="${imagePath(e)}" alt="${e}" draggable="false">`;
      trayEl.appendChild(it);
    });

    setTimeBasedBackground(currentContent);

    let matched = 0;
    const totalNeeded = 1;
    let activeClone = null;
    let activeSource = null;
    let selectedForTap = null;

    function basketAtPoint(x, y) {
      const el = document.elementFromPoint(x, y);
      return el ? el.closest('.basket') : null;
    }

    function createClone(text, x, y) {
      const c = document.createElement('div');
      c.className = 'item dragging';
      c.style.position = 'fixed';
      c.style.left = (x - 36) + 'px';
      c.style.top = (y - 36) + 'px';
      c.style.zIndex = 9999;
      c.style.pointerEvents = 'none';
      c.innerHTML = `<img src="${imagePath(text)}" alt="${text}" draggable="false">`;
      document.body.appendChild(c);
      return c;
    }

    function destroyClone() {
      if (activeClone) { activeClone.remove(); activeClone = null; }
      if (activeSource) activeSource.classList.remove('dragging');
      activeSource = null;
    }

    function isMatch(basket, emoji) {
      // Sorting game (unchanged)
      if (gameMode === "sorting") {
        return basket.dataset.item === emoji;
      }

      // Flowers game
      if (gameMode === "flowers") {
        return basket.dataset.item === "flowers" && chosenDataset.includes(emoji);
      }

      return false;
    }


    function placeInBasket(basket, emoji, content) {
      const src = trayEl.querySelector(`.item[data-item='${emoji}']`);
      if (src) src.remove();

      if (gameMode === "flowers") {
        // Make the dragged flower inside the basket opaque
        const basketImgs = Array.from(basket.querySelectorAll('.placed-item'));
        basketImgs.forEach(img => {
          if (img.alt === emoji) {
            img.style.opacity = '1.0'; // fade in the dragged flower
          }
        });
        // Also make the main basket image fully visible
        const basketMainImg = basket.querySelector('img:not(.placed-item)');
        if (basketMainImg) basketMainImg.style.opacity = '1.0';

        matched++;
      } else if (gameMode === "sorting") {
        basket.classList.add('filled');
        matched++;
      }
      // Find the faded target image inside the basket and make it visible
      const hintImg = basket.querySelector('.hint');
      if (hintImg) hintImg.style.opacity = '1.0';

      // Mark this basket as filled
      basket.classList.add('filled');


      // Update message
      messageEl.textContent = matched === totalNeeded ? content.text1 : '';

      if (matched === totalNeeded) {
        setTimeout(() => {
          fetch("/checkin", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ name: "Haniz Binte Omar", status: "checked in" })
          })
            .then(r => r.json())
            .then(() => { messageEl.textContent = content.text2; })
            .catch(() => { messageEl.textContent = content.text3; });
        }, 400);
      }
    }


    // --- Mouse drag ---
    let mouseMoveHandler = null, mouseUpHandler = null;
    function onItemMouseDown(e) {
      e.preventDefault();
      const item = e.currentTarget;
      const emoji = item.dataset.item;
      activeSource = item;
      activeSource.classList.add('dragging');
      activeClone = createClone(emoji, e.clientX, e.clientY);

      mouseMoveHandler = ev => {
        activeClone.style.left = (ev.clientX - 36) + 'px';
        activeClone.style.top = (ev.clientY - 36) + 'px';
      };
      mouseUpHandler = ev => {
        const basket = basketAtPoint(ev.clientX, ev.clientY);
        if (basket && isMatch(basket, emoji)) placeInBasket(basket, emoji, currentContent);
        else messageEl.textContent = currentContent.text4;
        destroyClone();
        document.removeEventListener('mousemove', mouseMoveHandler);
        document.removeEventListener('mouseup', mouseUpHandler);
      };

      document.addEventListener('mousemove', mouseMoveHandler);
      document.addEventListener('mouseup', mouseUpHandler);
    }

    // --- Touch drag ---
    let touchMoveHandler = null, touchEndHandler = null;
    function onItemTouchStart(e) {
      if (e.touches.length > 1) return;
      e.preventDefault();
      const item = e.currentTarget;
      const emoji = item.dataset.item;
      activeSource = item;
      activeSource.classList.add('dragging');
      const t = e.touches[0];
      activeClone = createClone(emoji, t.clientX, t.clientY);

      touchMoveHandler = ev => {
        if (!ev.touches.length) return;
        const tt = ev.touches[0];
        activeClone.style.left = (tt.clientX - 36) + 'px';
        activeClone.style.top = (tt.clientY - 36) + 'px';
      };

      touchEndHandler = ev => {
        const changed = ev.changedTouches && ev.changedTouches[0];
        const cx = changed ? changed.clientX : 0;
        const cy = changed ? changed.clientY : 0;
        const basket = basketAtPoint(cx, cy);
        if (basket && isMatch(basket, emoji)) placeInBasket(basket, emoji, currentContent);
        else messageEl.textContent = currentContent.text4;
        destroyClone();
        document.removeEventListener('touchmove', touchMoveHandler);
        document.removeEventListener('touchend', touchEndHandler);
      };

      document.addEventListener('touchmove', touchMoveHandler, { passive: false });
      document.addEventListener('touchend', touchEndHandler);
    }

    // --- Tap-to-select ---
    function onItemTap(e) {
      const it = e.currentTarget;
      if (selectedForTap === it) {
        it.classList.remove('selected');
        selectedForTap = null;
        messageEl.textContent = '';
        return;
      }
      if (selectedForTap) selectedForTap.classList.remove('selected');
      selectedForTap = it;
      it.classList.add('selected');
      messageEl.textContent = currentContent.text51 + it.dataset.item + currentContent.text52;
    }

    function onBasketTap(e) {
      const b = e.currentTarget;
      if (!selectedForTap) { messageEl.textContent = currentContent.text6; return; }
      const emoji = selectedForTap.dataset.item;
      if (isMatch(b, emoji)) placeInBasket(b, emoji, currentContent);
      else { messageEl.textContent = currentContent.text4; }
      selectedForTap.classList.remove('selected');
      selectedForTap = null;
    }

    // --- Attach handlers ---
    document.querySelectorAll('.item').forEach(it => {
      it.addEventListener('mousedown', onItemMouseDown);
      it.addEventListener('touchstart', onItemTouchStart, { passive: false });
      it.addEventListener('click', onItemTap);
    });
    document.querySelectorAll('.basket').forEach(b => {
      b.addEventListener('click', onBasketTap);
    });
  </script>
</body>

</html>